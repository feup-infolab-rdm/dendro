const async = require("async");
const slug = require("slug");
const _ = require("underscore");
const Pathfinder = global.Pathfinder;
const Utils = require(Pathfinder.absPathInPublicFolder("/js/utils.js")).Utils;
const CKAN = require("ckan");
const isNull = require(Pathfinder.absPathInSrcFolder("/utils/null.js")).isNull;
const Elements = require(Pathfinder.absPathInSrcFolder("/models/meta/elements.js")).Elements;
const Logger = require(Pathfinder.absPathInSrcFolder("utils/logger.js")).Logger;
const Folder = require(Pathfinder.absPathInSrcFolder("/models/directory_structure/folder.js")).Folder;
const File = require(Pathfinder.absPathInSrcFolder("/models/directory_structure/file.js")).File;
const Config = require(Pathfinder.absPathInSrcFolder("models/meta/config.js")).Config;
const generalDatasetUtils = require(Pathfinder.absPathInSrcFolder("/utils/datasets/generalDatasetUtils.js"));

// ------CKAN UTILS FOR BOTH EXPORT_TO_CKAN AND CALCULATE_CKAN_DIFFS-----------

/**
 * Creates a resource ID for a resource to be exported to Ckan via Dendro. This is useful in a sense that it allows us to understand where the file was created(in the Ckan Webapp or in the Dendro Webapp)
 * @param fileName the name of the resource in Dendro
 */
const createCkanFileIdBasedOnDendroFileName = function (fileName)
{
    const slug = require("slug");
    let newCkanFileID = slug(fileName) + "_exported_by_dendro_" + fileName;
    return newCkanFileID;
};

/**
 * Checks if a Ckan resource was created in Dendro or not
 * @param ckanFile a ckan file object, MUST contain the id property
 */
const verifyIfCkanFileWasCreatedInDendro = function (ckanFile)
{
    let ckanFileID = ckanFile.id;
    let ckanFileIDParts = ckanFileID.split("_exported_by_dendro_");
    const slug = require("slug");
    // backup6txt_exported_by_dendro_backup6.txt
    if (ckanFileIDParts.length !== 2 || slug(ckanFileIDParts[1]) !== ckanFileIDParts[0])
    {
        return false;
    }
    return true;
};

/**
 * Given an array of names of resources in Dendro, returns an array of fileIds generated by Dendro(based on createCkanFileIdBasedOnDendroFileName) this function is used when comparing the files that are missing in a Ckan package versus a Dendro folder and vice versa
 * @param namesOfResourcesInDendro an array containing the resource names present in a Dendro package
 */
const buildCkanFileIDsFromDendroFileNames = function (namesOfResourcesInDendro)
{
    let ckanIdOfResourcesInDendro = [];

    for (let i = 0; i < namesOfResourcesInDendro.length; i++)
    {
        ckanIdOfResourcesInDendro.push(createCkanFileIdBasedOnDendroFileName(namesOfResourcesInDendro[i]));
    }

    return ckanIdOfResourcesInDendro;
};

/**
 * Returns the Date value at which a Dendro package was last exported to Ckan, this function is useful to later calculate which files where added/deleted on both Ckan and Dendro sides
 * @param packageID the packageId in Ckan
 * @param client the Ckan client object
 * @param callback the callback function
 */
const getExportedAtByDendroForCkanDataset = function (packageID, client, callback)
{
    client.action("package_show",
        {
            id: packageID
        },
        function (err, result)
        {
            if (result.success)
            {
                let exportedAtDate = _.filter(result.result.extras, function (extra)
                {
                    return extra.key === Elements.ontologies.ddr.exportedAt.uri;
                });
                if (isNull(exportedAtDate) || exportedAtDate.length !== 1)
                {
                    callback(true, "There is no property exportedAt for this ckan dataset: packageID : " + packageID);
                }
                else
                {
                    callback(err, exportedAtDate[0].value);
                }
            }
            else
            {
                callback(err, result);
            }
        });
};

/**
 * Returns dendroDiffs, an array of objects with the properties 'id' and 'event'. 'id' identifies an existing/or not ckan resource and 'event' can be "deleted_in_local" or "created_in_local". If the event is "deleted_in_local" it means that a resource was deleted in Dendro and should also be deleted in ckan
 * @param folder the folder object in dendro
 * @param packageId the packageId in Ckan
 * @param client the Ckan client object
 * @param callback the callback function
 */
const calculateDendroDiffs = function (folder, packageId, client, callback)
{
    let lastExportedAtDate = null;
    let folderResourcesInDendro = null;
    let folderResourcesInCkan = null;
    let dendroDiffs = [];
    let createdInLocal = [];
    let deletedInLocal = [];
    let includeSoftDeletedChildren = true;
    getExportedAtByDendroForCkanDataset(packageId, client, function (err, exportedAtDate)
    {
        if (isNull(err))
        {
            lastExportedAtDate = exportedAtDate;
            client.action("package_show",
                {
                    id: packageId
                },
                function (err, result)
                {
                    if (result.success)
                    {
                        folderResourcesInCkan = result.result.resources;
                        folder.getChildrenRecursive(function (err, children)
                        {
                            if (isNull(err))
                            {
                                folderResourcesInDendro = children;
                                let namesOfResourcesInDendro = _.pluck(folderResourcesInDendro, "name");
                                let dendroMetadataFiles = [folder.nie.title + ".zip", folder.nie.title + ".rdf", folder.nie.title + ".txt", folder.nie.title + ".json"];
                                namesOfResourcesInDendro = namesOfResourcesInDendro.concat(dendroMetadataFiles);
                                let ckanIdOfResourcesInDendro = buildCkanFileIDsFromDendroFileNames(namesOfResourcesInDendro);
                                let ckanIdOfResourcesInCkan = _.pluck(folderResourcesInCkan, "id");
                                let dendroIsMissing = _.difference(ckanIdOfResourcesInCkan, ckanIdOfResourcesInDendro);
                                let ckanIsMissing = _.difference(ckanIdOfResourcesInDendro, ckanIdOfResourcesInCkan);

                                async.parallel([
                                    function (callback)
                                    {
                                        if (dendroIsMissing.length > 0)
                                        {
                                            async.mapSeries(dendroIsMissing, function (missingFile, callback)
                                            {
                                                let ckanFile = _.find(folderResourcesInCkan, function (folderResourcesInCkan)
                                                {
                                                    return folderResourcesInCkan.id === missingFile;
                                                });

                                                if (verifyIfCkanFileWasCreatedInDendro(ckanFile))
                                                {
                                                    // it was deleted in dendro
                                                    // delete in ckan
                                                    let ckanfileEvent = {
                                                        id: ckanFile.id,
                                                        event: "deleted_in_local"
                                                    };
                                                    // dendroDiffs.push(ckanfileEvent);
                                                    deletedInLocal.push(ckanfileEvent);
                                                    callback(err, ckanfileEvent);
                                                }
                                                else
                                                {
                                                    // TODO Here are the files were created in the ckan side-> shall we delete these files???
                                                    callback(err, null);
                                                }
                                            }, function (err, results)
                                            {
                                                callback(err, results);
                                            });
                                        }
                                        else
                                        {
                                            callback(err, null);
                                        }
                                    },
                                    function (callback)
                                    {
                                        if (ckanIsMissing.length > 0)
                                        {
                                            async.mapSeries(ckanIsMissing, function (missingFile, callback)
                                            {
                                                let ckanfileEvent = {
                                                    id: missingFile,
                                                    event: "created_in_local"
                                                };
                                                // dendroDiffs.push(ckanfileEvent);
                                                createdInLocal.push(ckanfileEvent);
                                                callback(err, ckanfileEvent);
                                            }, function (err, results)
                                            {
                                                callback(err, results);
                                            });
                                        }
                                        else
                                        {
                                            callback(err, null);
                                        }
                                    }
                                ],
                                function (err, results)
                                {
                                    // callback(err, results);
                                    dendroDiffs = createdInLocal.concat(deletedInLocal);
                                    callback(err, dendroDiffs);
                                });
                            }
                            else
                            {
                                callback(err, children);
                            }
                        }, includeSoftDeletedChildren);
                    }
                    else
                    {
                        callback(err, result);
                    }
                });
        }
        else
        {
            callback(err, exportedAtDate);
        }
    });
};

/**
 * Created and returns a package id for a Ckan export. The code inside this function was repeated a lot in the code base, so this function was needed
 * @param resourceUri the unique resource identifier for a resource(a folder) in Dendro that is to be exported to Ckan
 */
const createPackageID = function (resourceUri)
{
    // ckan only accepts alphanumeric characters and dashes for the dataset ids
    // slugifiedTitle = slugifiedTitle.replace(/[^A-Za-z0-9-]/g, "").replace(/\./g, "").toLowerCase();
    if (isNull(resourceUri))
    {
        return null;
    }
    let packageId = slug(resourceUri, "-");
    packageId = packageId.replace(/[^A-Za-z0-9-]/g, "-").replace(/\./g, "-").toLowerCase();
    return packageId;
};

/**
 * Checks if a certain resource in Dendro that is to be exported to Ckan has all the required metadata so that the export process works(dcterms:title; dcterms:description)
 * @param requestedResourceUri the unique resource identifier for a resource(a folder) in Dendro that is to be exported to Ckan
 * @param callback the callback
 */
const checkIfResourceHasTheRequiredMetadataForExport = function (requestedResourceUri, callback)
{
    Folder.findByUri(requestedResourceUri, function (err, folder)
    {
        if (!isNull(err))
        {
            let errorInfo = {
                error: {
                    message: "Error fetching " + requestedResourceUri + " from the Dendro platform. Error reported : " + folder,
                    statusCode: 500
                }
            };
            Logger.log("error", JSON.stringify(errorInfo));
            callback(err, errorInfo);
        }
        else if (isNull(folder))
        {
            let errorInfo = {
                error: {
                    message: requestedResourceUri + " does not exist in Dendro or is not a folder. You cannot export an entire project to an external repository.",
                    statusCode: 404
                }
            };
            Logger.log("error", JSON.stringify(errorInfo));
            callback(true, errorInfo);
        }
        else
        {
            // A folder existe, verificar os descritores
            if (isNull(folder.dcterms.title))
            {
                let errorInfo = {
                    error: {
                        message: "Folder " + folder.uri + " has no title! Please set the Title property (from the dcterms metadata schema) and try the exporting process again.",
                        statusCode: 400
                    }
                };
                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, errorInfo);
            }
            else if (isNull(folder.dcterms.description))
            {
                let errorInfo = {
                    error: {
                        message: "Folder " + folder.uri + " has no description! Please set the Description property (from the dcterms metadata schema) and try the exporting process again.",
                        statusCode: 400
                    }
                };
                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, errorInfo);
            }
            else
            {
                callback(null, folder, null);
            }
        }
    });
};

/**
 * Gets both the ckanDiffs(an array with all the resources in ckan that were changed since the last time a dendro package was exported to ckan) and dendroDiffs(an array with all the resources in dendro that were added/deleted since the last time a dendro package was exported to ckan)
 * @param requestedResourceUri the unique resource identifier for a resource(a folder) in Dendro that is to be exported to Ckan
 * @param targetRepository a Ckan repository object containing the properties ddr.hasExternalUri and ddr.hasAPIKey
 * @param callback the callback
 */
const getBothDendroDiffsAndCkanDiffs = function (requestedResourceUri, targetRepository, callback)
{
    const client = new CKAN.Client(targetRepository.ddr.hasExternalUri, targetRepository.ddr.hasAPIKey);
    let exportedAtDate = null;
    let changedResourcesInCkan = [];

    Folder.findByUri(requestedResourceUri, function (err, folder)
    {
        if (isNull(err))
        {
            if (!isNull(folder))
            {
                let packageId = createPackageID(folder.uri);
                client.action("package_show",
                    {
                        id: packageId
                    },
                    function (err, result)
                    {
                        if (!isNull(err) && isNull(result))
                        {
                            const message = "[ERROR] invalid ckan uri or api key";
                            Logger.log("error", JSON.stringify(err));
                            let info = {
                                error: {
                                    message,
                                    statusCode: 400
                                }
                            };
                            callback(true, info);
                        }
                        else
                        {
                            if (result.success)
                            {
                                getExportedAtByDendroForCkanDataset(packageId, client, function (err, result)
                                {
                                    if (isNull(err))
                                    {
                                        // package exists and was exported by Dendro before
                                        exportedAtDate = result;
                                        client.getChangesInDatasetAfterDate(exportedAtDate, packageId, function (err, result)
                                        {
                                            if (result.success)
                                            {
                                                changedResourcesInCkan = result.result.changedResources;
                                                calculateDendroDiffs(folder, packageId, client, function (err, diffs)
                                                {
                                                    if (isNull(err))
                                                    {
                                                        callback(err, {
                                                            dendroDiffs: diffs,
                                                            ckanDiffs: changedResourcesInCkan
                                                        });
                                                    }
                                                    else
                                                    {
                                                        let message = "Error comparing a dendro package with a ckan package";
                                                        Logger.log("error", message);
                                                        callback(err, diffs);
                                                    }
                                                });
                                            }
                                            else
                                            {
                                                let message = "Error getting changedResources from ckan repository";
                                                Logger.log("error", message);
                                                callback(err, result);
                                            }
                                        });
                                    }
                                    else
                                    {
                                        let message = "Error getting the exportedAt property from ckan";
                                        Logger.log("error", message);
                                        callback(err, result);
                                    }
                                });
                            }
                            else
                            {
                                let message = "The ckan package to export does not exist";
                                Logger.log(message);
                                callback(err, result);
                            }
                        }
                    });
            }
            else
            {
                let message = "The folder to export to ckan does not exist";
                Logger.log("error", message);
                callback(true, message);
            }
        }
        else
        {
            let message = "Error when looking for the folder to export to ckan";
            Logger.log("error", message);
            callback(true, message);
        }
    });
};

/**
 * Used as the controller function for the route calculate_ckan_repository_diffs and also used as an aux function for the route export_to_repository if the repository is of type Ckan
 * returns the ckanDiffs and dendroDiffs as a diffs object {dendroDiffs: diffs, ckanDiffs: changedResourcesInCkan}
 * @param requestedResourceUri the unique resource identifier for a resource(a folder) in Dendro that is to be exported to Ckan
 * @param targetRepository a Ckan repository object containing the properties ddr.hasExternalUri and ddr.hasAPIKey
 * @param callback the callback
 */
const calculateCkanRepositoryDiffs = function (requestedResourceUri, targetRepository, callback)
{
    async.waterfall([
        function (callback)
        {
            checkIfResourceHasTheRequiredMetadataForExport(requestedResourceUri, function (err, folder)
            {
                callback(err, folder);
            });
        },
        function (folder, callback)
        {
            getBothDendroDiffsAndCkanDiffs(requestedResourceUri, targetRepository, function (err, diffs)
            {
                callback(err, diffs);
            });
        }
    ], function (err, diffs)
    {
        if (isNull(err))
        {
            callback(err, diffs);
        }
        else
        {
            let message = "";
            if (!isNull(diffs.error) && !isNull(diffs.error.message) && diffs.error.message === "Not found")
            {
                // There are no diffs because the package was not exported previously
                callback(null, "Package was not previously exported");
            }
            else
            {
                let message, statusCode;
                if (!isNull(diffs.error) && !isNull(diffs.error.message))
                {
                    message = "Error when calculating diffs between Dendro and Ckan: " + diffs.error.message;
                }
                else
                {
                    message = "Error when calculating diffs between Dendro and Ckan: " + JSON.stringify(diffs);
                }

                if (!isNull(diffs.error) && !isNull(diffs.error.statusCode))
                {
                    statusCode = diffs.error.statusCode;
                }
                else
                {
                    statusCode = 500;
                }

                let errorInfo = {
                    error: {
                        message: message,
                        statusCode: statusCode
                    }
                };
                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, errorInfo);
            }
        }
    });
};

// ------CKAN UTILS FOR EXPORT_TO_CKAN-----------
/**
 * Util function used before an export to ckan. Given the dendroDiffs and ckanDiffs calculated, checks if the user gave permission to propagate the dendroDiffs to ckan or reject the changes from the ckan side(ckanDiffs)
 * @param checkPermissionsDictionary JSON object detailing if the user authorized the dendroDiffs or ckanDiffs example -> {"dendroDiffs" : true/false,"ckanDiffs" : true/false};
 * @param permissionsToCheck the diffs that were calculated previously in calculateCkanRepositoryDiffs
 * @param callback the callback
 */
const validateChangesPermissions = function (checkPermissionsDictionary, permissionsToCheck, callback)
{
    let validated = false;
    async.mapSeries(permissionsToCheck, function (permission, cb)
    {
        if (!checkPermissionsDictionary[permission])
        {
            const message = "Missing the permission: " + permission;
            cb(true, message);
        }
        else
        {
            validated = true;
            cb(false, validated);
        }
    }, function (err, results)
    {
        if (isNull(err))
        {
            validated = true;
            callback(err, validated);
        }
        else
        {
            let errorInfo = {
                message: JSON.stringify(results),
                statusCode: 412
            };
            Logger.log("error", JSON.stringify(errorInfo));
            callback(err, null, errorInfo);
        }
    });
};

/**
 * Util function that adds or updates the exportedAt property to a Ckan package, this property is used to check when a ckan package was last exported from Dendro
 * @param packageID the Ckan package ID
 * @param client the Ckan client
 * @param callback the callback
 * @param date an optional parameter. It is the new date value that is going to be associated to the property ddr:exportedAt. If this parameter is not passed the current date in runtime is used instead
 */
const updateOrInsertExportedAtByDendroForCkanDataset = function (packageID, client, callback, date)
{
    // This is a timeout of 3 seconds.This is not pretty but it is necessary for the tests to pass.
    // This hack is not needed for the export to work in the webApp. Only for the tests
    setTimeout(function ()
    {
        client.action("package_show",
            {
                id: packageID
            },
            function (err, result)
            {
                if (result.success)
                {
                    // call package_update with the new date to update the exportedAt
                    // returns the index where the property is located, if the property does not exist returns -1
                    // the new exportedAt date is going to be the new date at which the package was updated in ckan(metadata_modified plus 3 milliseconds-> so that the automated tests work) after the latest export from dendro. Using simply "new Date()" was causing bugs because there are time differences between ckan and dendro even if the update exported at is called at the correct time
                    let dateObject = new Date(result.result.metadata_modified);
                    // This is very ugly but necessary for the automated tests to work. In the webapp this is not needed. Only the automated tests require this hack
                    // dateObject.setMilliseconds(dateObject.getMilliseconds() + 3000);
                    let newExportedAt = dateObject.toISOString();
                    let resultIndex = _.findIndex(result.result.extras, function (extra)
                    {
                        return extra.key === Elements.ontologies.ddr.exportedAt.uri;
                    });
                    Logger.log("The index is: " + resultIndex);

                    if (isNull(date))
                    {
                        date = newExportedAt;
                    }

                    let dendroExportedAt = {
                        key: Elements.ontologies.ddr.exportedAt.uri,
                        value: date
                    };

                    if (resultIndex === -1)
                    {
                        // this is the first time that dendro is exporting this dataset to ckan
                        result.result.extras.push(dendroExportedAt);
                    }
                    else
                    {
                        // this is not the first time that dendro is exporting this dataset to ckan
                        // lets update the exportDate
                        result.result.extras[resultIndex] = dendroExportedAt;
                    }

                    client.action(
                        "package_update",
                        result.result,
                        function (err, result)
                        {
                            if (result.success)
                            {
                                Logger.log("exportedAt was updated/created in ckan");
                                callback(err, result);
                            }
                            else
                            {
                                Logger.log("error", "Error updating/creating exportedAt in ckan");
                                callback(err, result);
                            }
                        }
                    );
                }
                else
                {
                    callback(err, result);
                }
            });
    }, 10000);
};

/**
 * Util function that deletes a resource in Ckan. This is a soft delete, the resource is only marked as 'deleted'. This function is used when a file is deleted in Dendro and must also be deleted in Ckan to keep consistency
 * @param resourceID the ID of the resource to be soft deleted in Ckan
 * @param packageID the Ckan package ID that the resource belongs to
 * @param client the Ckan client
 * @param callback the callback
 */
const deleteResourceInCkan = function (resourceID, packageID, client, callback)
{
    client.action("resource_delete",
        {
            id: resourceID
        },
        function (err, result)
        {
            if (result.success)
            {
                Logger.log("The resource with id: " + resourceID + " was deleted");
                callback(err, result);
            }
            else
            {
                callback(err, result);
            }
        });
};

/**
 * Util function that checks if the package to be exported from Dendro to Ckan is a folder that is not empty and only has files as children.
 * @param resourceUri the unique resource identifier of a resource(folder) in Dendro
 * @param callback the callback
 */
const checkResourceTypeAndChildren = function (resourceUri, callback)
{
    Folder.findByUri(resourceUri, function (err, folder)
    {
        if (isNull(err))
        {
            if (isNull(folder))
            {
                let errorInfo = {
                    message: "The folder to export does not exist in Dendro. Are you sure you selected a folder?",
                    statusCode: 404
                };
                callback(true, null, errorInfo);
            }
            else
            {
                let includeSoftDeletedChildren = true;
                folder.getChildrenRecursive(function (err, children)
                {
                    if (isNull(err))
                    {
                        Logger.log("info", "The children are: " + JSON.stringify(children));
                        if (isNull(children) || children.length <= 0)
                        {
                            const errorMessage = "Error, you cannot export an empty folder to Ckan";
                            Logger.log("error", errorMessage);
                            let errorInfo = {
                                message: errorMessage,
                                statusCode: 412
                            };
                            callback(true, null, errorInfo);
                        }
                        else
                        {
                            // TODO check if all of the children is of type file
                            /* callback(err, children); */
                            async.mapSeries(children, function (child, cb)
                            {
                                Folder.findByUri(child.uri, function (err, folder)
                                {
                                    if (isNull(err))
                                    {
                                        if (isNull(folder))
                                        {
                                            cb(err, folder);
                                        }
                                        else
                                        {
                                            let errorInfo = {
                                                message: "Error, you can only export folders that have files and not folders.",
                                                statusCode: 412
                                            };
                                            return callback(true, null, errorInfo);
                                        }
                                    }
                                    else
                                    {
                                        let errorInfo = {
                                            message: "Error when looking for information about a folder child. Child: " + child.uri + " error: " + JSON.stringify(folder),
                                            statusCode: 500
                                        };
                                        return callback(true, null, errorInfo);
                                    }
                                });
                            }, function (err, results)
                            {
                                callback(err, children);
                            });
                        }
                    }
                    else
                    {
                        let errorInfo = {
                            message: "Error when searching for folder " + resourceUri + " children: " + JSON.stringify(children),
                            statusCode: 500
                        };
                        callback(err, null, errorInfo);
                    }
                }, includeSoftDeletedChildren);
            }
        }
        else
        {
            let errorInfo = {
                message: "Error when searching for the folder to export in Dendro: " + JSON.stringify(folder),
                statusCode: 500
            };
            callback(err, null, errorInfo);
        }
    });
};

/**
 * Util function that creates or updates files in a Ckan package
 * @param targetRepository a Ckan repository object containing the properties ddr.hasExternalUri and ddr.hasAPIKey
 * @param datasetFolderMetadata the metadata of the parent folder (package) of the files
 * @param packageId the ckan id of the package
 * @param client the Ckan client
 * @param callback the callback
 * @param overwrite if set to true will overwrite any preexisting files in the package
 * @param extraFiles extra files(in json, zip, txt and rdf formats) detailing the full metadata of the package(as well as including all the metadata of the files contained in the package)
 */
const createOrUpdateFilesInPackage = function (targetRepository, datasetFolderMetadata, packageId, client, callback, overwrite, extraFiles)
{
    const files = [];
    const locations = [];
    let i;

    for (i = 0; i < datasetFolderMetadata.original_node.nie.hasLogicalPart.length; i++)
    {
        const child = datasetFolderMetadata.children[i];
        if (!isNull(child))
        {
            if (child.original_node instanceof File)
            {
                files.push(child.original_node);
                locations.push(datasetFolderMetadata.children[i].temp_location);
            }
            else
            {
                return callback(1, "There was an error preparing a file in the server: " + JSON.stringify(child));
            }
        }
    }

    const resources = [];
    const path = require("path");

    for (i = 0; i < files.length; i++)
    {
        const file = files[i];
        let location = locations[i];

        let fileExtension = path.extname(location).substr(1);
        let fileName = path.basename(location);

        let record =
      {
          absolute_file_path: location,
          url: targetRepository.ddr.hasExternalUri + "/dataset/" + packageId + "/resource/" + fileName,
          package_id: packageId,
          description: file.dcterms.description || "< no description available >",
          filename: file.dcterms.title || fileName,
          mimetype: Config.mimeType(fileExtension),
          extension: fileExtension,
          format: fileExtension.toUpperCase(),
          overwrite_if_exists: overwrite,
          id: createCkanFileIdBasedOnDendroFileName(fileName)
      };

        resources.push(record);
    }

    for (i = 0; i < extraFiles.length; i++)
    {
        let location = extraFiles[i];

        let fileExtension = path.extname(location).substr(1);
        let fileName = path.basename(location);

        let record =
      {
          absolute_file_path: location,
          url: targetRepository.ddr.hasExternalUri + "/dataset/" + packageId + "/resource/" + fileName,
          package_id: packageId,
          filename: fileName,
          mimetype: Config.mimeType(fileExtension),
          extension: fileExtension,
          format: fileExtension.toUpperCase(),

          overwrite_if_exists: true,
          id: createCkanFileIdBasedOnDendroFileName(fileName)
      };

        if (typeof Config.exporting.generated_files_metadata[fileExtension] !== "undefined")
        {
            record.description = Config.exporting.generated_files_metadata[fileExtension].dcterms.description;
        }
        else
        {
            record.description = "< no description available >";
        }

        resources.push(record);
    }

    client.upload_files_into_package(resources, packageId, function (err, result)
    {
        return callback(err, result);
    });
};

/**
 * Util function to create a new package in Ckan
 * @param targetRepository a Ckan repository object containing the properties ddr.hasExternalUri and ddr.hasAPIKey
 * @param parentFolderPath the location of the temp folder created in dendro's filesystem so that uploads can be processed
 * @param extraFiles extra files(in json, zip, txt and rdf formats) detailing the full metadata of the package(as well as including all the metadata of the files contained in the package)
 * @param packageData the package metadata
 * @param datasetFolderMetadata the metadata of the parent folder (package) of the files
 * @param packageId the ckan id of the new Ckan package
 * @param client the Ckan client
 * @param callback the callback
 * @param overwrite if set to true will overwrite any preexisting files in the package
 */
const createPackageInCkan = function (targetRepository, parentFolderPath, extraFiles, packageData, datasetFolderMetadata, packageId, client, callback, overwrite)
{
    if (isNull(overwrite))
    {
        overwrite = false;
    }
    client.action(
        "package_create",
        packageData,
        function (response, result)
        {
            if (result.success)
            {
                createOrUpdateFilesInPackage(targetRepository, datasetFolderMetadata, packageId, client, function (err, response)
                {
                    if (isNull(err))
                    {
                        const dataSetLocationOnCkan = targetRepository.ddr.hasExternalUri + "/dataset/" + packageId;
                        const message = "This dataset was exported to the CKAN instance and should be available at: <a href=\"" + dataSetLocationOnCkan + "\">" + dataSetLocationOnCkan + "</a> <br/><br/>";
                        callback(err, message);
                    }
                    else
                    {
                        let message = "Error uploading files in the dataset to CKAN.";
                        if (!isNull(response))
                        {
                            message += " Error returned : " + response;
                        }
                        callback(err, message);
                    }

                    generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
                }, overwrite, extraFiles);
            }
            else
            {
                let message = "Error exporting dataset to CKAN.";
                if (!isNull(response))
                {
                    message += " Error returned : " + response;
                }
                callback(true, message);

                generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
            }
        }
    );
};

/**
 * Util function to update an existing package in Ckan
 * @param requestedResourceUri the resource unique identifier of the folder in Dendro representative of the package in Ckan
 * @param targetRepository a Ckan repository object containing the properties ddr.hasExternalUri and ddr.hasAPIKey
 * @param parentFolderPath the location of the temp folder created in dendro's filesystem so that uploads can be processed
 * @param extraFiles extra files(in json, zip, txt and rdf formats) detailing the full metadata of the package(as well as including all the metadata of the files contained in the package)
 * @param packageData the package metadata
 * @param datasetFolderMetadata the metadata of the parent folder (package) of the files
 * @param packageId the ckan id of the new Ckan package
 * @param client the Ckan client
 * @param callback the callback
 * @param overwrite if set to true will overwrite any preexisting files in the package
 */
const updatePackageInCkan = function (requestedResourceUri, targetRepository, parentFolderPath, extraFiles, packageData, datasetFolderMetadata, packageId, client, callback, overwrite)
{
    if (isNull(overwrite))
    {
        overwrite = false;
    }

    async.waterfall([
        function (callback)
        {
            getBothDendroDiffsAndCkanDiffs(requestedResourceUri, targetRepository, function (err, diffs)
            {
                callback(err, diffs);
            });
        },
        function (diffs, callback)
        {
            client.action(
                "package_update",
                packageData.result,
                function (err, result)
                {
                    callback(err, diffs);
                }
            );
        },
        function (diffs, callback)
        {
            createOrUpdateFilesInPackage(targetRepository, datasetFolderMetadata, packageId, client, function (err, response)
            {
                if (isNull(err))
                {
                    const dataSetLocationOnCkan = targetRepository.ddr.hasExternalUri + "/dataset/" + packageId;
                    const finalMsg = "This dataset was exported to the CKAN instance and should be available at: <a href=\"" + dataSetLocationOnCkan + "\">" + dataSetLocationOnCkan + "</a> <br/><br/> The previous version was overwritten.";
                    async.mapSeries(diffs.dendroDiffs, function (dendroDiff, cb)
                    {
                        if (dendroDiff.event === "deleted_in_local")
                        {
                            deleteResourceInCkan(dendroDiff.id, packageId, client, function (err, result)
                            {
                                cb(err, result);
                            });
                        }
                        else
                        {
                            cb(err, null);
                        }
                    }, function (err, results)
                    {
                        if (isNull(err))
                        {
                            callback(err, results, finalMsg);
                            generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
                        }
                        else
                        {
                            let message = "Error uploading files in the dataset to CKAN.";
                            Logger.log("error", message);
                            callback(err, results, finalMsg);
                            generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
                        }
                    });
                }
                else
                {
                    let message = "Error uploading files in the dataset to CKAN: " + JSON.stringify(response);
                    Logger.log("error", message);
                    callback(err, response, message);
                    generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
                }
            }, overwrite, extraFiles);
        }
    ], function (err, result, finalMsg)
    {
        callback(err, result, finalMsg);
    });
};

/**
 * Util function to really delete a Ckan package(not a soft delete). This function is only used in Dendro when an error occurs during the creation of the package for the first time (in createPackageInCkan). This happens so that a corrupted package is not wasting any space in ckan and the user can try to export again via Dendro
 * @param client the Ckan client
 * @param datasetID the ckan id of the new package to be purged(deleted permanently)
 * @param callback the callback
 */
const purgeCkanDataset = function (client, datasetID, callback)
{
    client.action("dataset_purge",
        {
            id: datasetID
        },
        function (err, result)
        {
            callback(err, result);
        });
};

/**
 * Util function that builds the permissions that need to be checked by the user for the export to occur
 * @param requestedResourceUri the dendro folder uri to be exported to Ckan
 * @param targetRepository the CKAN respository
 * @param callback the callback
 */
const buildPermissionsToBeCheck = function (requestedResourceUri, targetRepository, callback)
{
    let checksNeeded = [];
    calculateCkanRepositoryDiffs(requestedResourceUri, targetRepository, function (err, diffs)
    {
        if (isNull(err))
        {
            if (diffs instanceof Object)
            {
                _.each(diffs, function (val, key)
                {
                    if (val.length > 0)
                    {
                        checksNeeded.push(key.toString());
                    }
                });
                callback(err, checksNeeded);
            }
            else
            {
                callback(err, checksNeeded);
            }
        }
        else
        {
            let errorInfo = {
                message: diffs.error.message,
                statusCode: diffs.error.statusCode
            };
            callback(err, null, errorInfo);
        }
    });
};

/**
 * Util function that that checks if a folder to export contains the metadata(dcterms:title, dcterms:description) and if the ckan respository has the hasExternalUri property
 * @param requestedResourceUri the dendro folder uri to be exported to Ckan
 * @param targetRepository the CKAN respository
 * @param callback the callback
 */
const checkIfFolderAndTargetRepositoryHaveRequiredMetadata = function (requestedResourceUri, targetRepository, callback)
{
    Folder.findByUri(requestedResourceUri, function (err, folder)
    {
        if (!isNull(err))
        {
            let errorInfo = {
                message: "Error fetching " + requestedResourceUri + " from the Dendro platform. Error reported : " + folder,
                statusCode: 500
            };
            Logger.log("error", JSON.stringify(errorInfo));
            callback(err, folder, errorInfo);
        }
        else if (isNull(folder))
        {
            let errorInfo = {
                message: requestedResourceUri + " does not exist in Dendro or is not a folder. You cannot export an entire project to an external repository.",
                statusCode: 400
            };
            Logger.log("error", JSON.stringify(errorInfo));
            callback(true, folder, errorInfo);
        }
        else
        {
            // A folder existe, verificar os descritores
            if (isNull(folder.dcterms.title))
            {
                let errorInfo = {
                    message: "Folder " + folder.uri + " has no title! Please set the Title property (from the dcterms metadata schema) and try the exporting process again.",
                    statusCode: 400
                };

                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, folder, errorInfo);
            }
            else if (isNull(folder.dcterms.description))
            {
                let errorInfo = {
                    message: "Folder " + folder.uri + " has no description! Please set the Description property (from the dcterms metadata schema) and try the exporting process again.",
                    statusCode: 400
                };

                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, folder, errorInfo);
            }
            else if (isNull(targetRepository.ddr.hasExternalUri))
            {
                let errorInfo = {
                    message: "No target repository URL specified. Check the value of the ddr.hasExternalUri attribute",
                    statusCode: 500
                };

                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, folder, errorInfo);
            }
            else
            {
                callback(null, folder);
            }
        }
    });
};

/**
 * Util function that builds the extrasJSONArray(with all the metadata of the folder to be exported)
 * @param folder a dendro folder to be exported to Ckan
 * @param callback the callback
 */
const buildExtrasJSONArray = function (folder, callback)
{
    // build extrasJSONArray
    const jsonDescriptors = folder.getDescriptors([Elements.access_types.private, Elements.access_types.locked]);

    const extrasJSONArray = [];

    jsonDescriptors.forEach(function (column)
    {
        const extraJson = {};
        extraJson.key = column.uri;
        extraJson.value = column.value;
        extrasJSONArray.push(extraJson);
    });

    callback(null, folder, extrasJSONArray);
};

/**
 * Util function that builds a Ckan package to be exported to ckan
 * @param client the Ckan client
 * @param organization the Ckan organization where the package will be exported to
 * @param targetRepository the Ckan repository
 * @param extrasJSONArray the extrasJSONArray(with all the metadata of the folder to be exported)
 * @param folder the Dendro folder to be exported
 * @param callback the callback
 */
const buildPackageForCkanExport = function (client, organization, targetRepository, extrasJSONArray, folder, callback)
{
    /** Check if organization exists**/
    client.action("organization_show",
        {
            id: targetRepository.ddr.hasOrganization
        },
        function (err, info)
        {
            if (isNull(err))
            {
                let packageId = createPackageID(folder.uri);
                folder.createTempFolderWithContents(true, true, true, function (err, parentFolderPath, absolutePathOfFinishedFolder, datasetFolderMetadata)
                {
                    if (isNull(err))
                    {
                        generalDatasetUtils.createPackage(parentFolderPath, folder, function (err, files, extraFiles)
                        {
                            if (isNull(err))
                            {
                                const packageContents = [
                                    {
                                        name: packageId,
                                        package_id: packageId,
                                        title: folder.dcterms.title,
                                        notes: folder.dcterms.description,
                                        extras: extrasJSONArray,
                                        owner_org: organization
                                    }
                                ];

                                client.action("package_show",
                                    {
                                        id: packageId
                                    },
                                    function (err, result)
                                    {
                                        // dataset was found, do we want to update or not?
                                        // TODO callback here
                                        // callback(err, result, parentFolderPath, packageId, extraFiles, datasetFolderMetadata, client, packageContents);
                                        // tem de ser com error a false caso contrário entra logo no último callback
                                        callback(null, result, parentFolderPath, packageId, extraFiles, datasetFolderMetadata, client, packageContents);
                                    }
                                );
                            }
                            else
                            {
                                let errorInfo = {
                                    message: "Error creating package for export folder " + folder.nie.title + " from the Dendro platform.",
                                    statusCode: 500
                                };

                                Logger.log("error", JSON.stringify(errorInfo));
                                callback(true, folder, errorInfo);
                            }
                        }, datasetFolderMetadata);
                    }
                    else
                    {
                        let errorInfo = {
                            message: "Error creating temporary folder for export folder " + folder.nie.title + " from the Dendro platform.",
                            statusCode: 500
                        };
                        Logger.log("error", JSON.stringify(errorInfo));
                        callback(true, folder, errorInfo);
                    }
                });
            }
            else
            {
                let message = "Unable to check if organization " + targetRepository.ddr.hasOrganization + "  exists.";

                if (!isNull(info) && !isNull(info.error) && (typeof info.error.message === "string"))
                {
                    message += " Error returned : " + info.error.message;
                }

                let errorInfo = {
                    message: message,
                    statusCode: 401
                };
                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, folder, errorInfo);
            }
        });
};

/**
 * Util function that exports package to a ckan target repository
 * @param overwrite if you want to overwrite existing files set this to true
 * @param requestedResourceUri the dendro folder uri that is going to be exported
 * @param targetRepository the Ckan repository
 * @param resultFromPackageExists the info from the package_show action
 * @param parentFolderPath the location of the temp folder created in dendro's filesystem so that uploads can be processed
 * @param packageID the Ckan package ID
 * @param extraFiles the metadata extra files(in rdf, JSON, txt)
 * @param datasetFolderMetadata the metadata of the folder
 * @param client the Ckan client
 * @param packageContents the package metadata
 * @param callback the callback
 */
const exportPackageToCkan = function (overwrite, requestedResourceUri, targetRepository, resultFromPackageExists, parentFolderPath, packageId, extraFiles, datasetFolderMetadata, client, packageContents, callback)
{
    if (resultFromPackageExists.success)
    {
        Utils.copyFromObjectToObject(packageContents[0], resultFromPackageExists.result);
        // get exportedAt and save it here
        let lastExportedAt;
        getExportedAtByDendroForCkanDataset(packageId, client, function (err, exportedAt)
        {
            if (isNull(err))
            {
                lastExportedAt = exportedAt;
                updatePackageInCkan(requestedResourceUri, targetRepository, parentFolderPath, extraFiles, resultFromPackageExists, datasetFolderMetadata, packageId, client, function (err, result, finalMsg)
                {
                    if (isNull(err))
                    {
                        let resultInfo = {
                            result: "OK",
                            message: finalMsg
                        };
                        callback(null, packageId, resultInfo);
                    }
                    else
                    {
                        // if an error occured updating the package in Ckan
                        // set exportedAt again to the old exportedAt date
                        updateOrInsertExportedAtByDendroForCkanDataset(packageId, client, function (err, data)
                        {
                            if (typeof finalMsg !== "string")
                            {
                                finalMsg = JSON.stringify(finalMsg);
                                if (finalMsg.indexOf("upload too large") !== -1)
                                {
                                    finalMsg = "Upload size per file exceeded for your Ckan instance! Contact you system administrator";
                                }
                            }
                            else
                            {
                                if (finalMsg.indexOf("upload too large") !== -1)
                                {
                                    finalMsg = "Upload size per file exceeded for your Ckan instance! Contact you system administrator";
                                }
                            }
                            const message = "Error exporting package to CKAN: " + finalMsg;
                            let errorInfo = {
                                message: message,
                                statusCode: 500
                            };
                            Logger.log("error", JSON.stringify(errorInfo));
                            callback(true, packageId, errorInfo);
                        }, lastExportedAt);
                    }
                }, overwrite);
            }
            else
            {
                const message = "Error exporting package to CKAN: this package does not have the exportedAt property even though it was previously exported by Dendro";
                let errorInfo = {
                    message: message,
                    statusCode: 500
                };
                Logger.log("error", JSON.stringify(errorInfo));
                callback(true, packageId, errorInfo);
            }
        });
    }
    // dataset not found
    else if (!resultFromPackageExists.success && resultFromPackageExists.error.__type === "Not Found Error")
    {
        createPackageInCkan(targetRepository, parentFolderPath, extraFiles, packageContents[0], datasetFolderMetadata, packageId, client, function (err, finalMsg)
        {
            if (isNull(err))
            {
                let resultInfo = {
                    result: "OK",
                    message: finalMsg
                };
                callback(null, packageId, resultInfo);
            }
            else
            {
                // there was an error trying to create the package
                // delete what was created of the corrupted package in ckan
                purgeCkanDataset(client, packageId, function (err, info)
                {
                    if (typeof finalMsg !== "string")
                    {
                        finalMsg = JSON.stringify(finalMsg);
                        if (finalMsg.indexOf("upload too large") !== -1)
                        {
                            finalMsg = "Upload size per file exceeded for your Ckan instance! Contact you system administrator";
                        }
                    }
                    else
                    {
                        if (finalMsg.indexOf("upload too large") !== -1)
                        {
                            finalMsg = "Upload size per file exceeded for your Ckan instance! Contact you system administrator";
                        }
                    }

                    const message = "Error: " + finalMsg;
                    let errorInfo = {
                        message: message,
                        statusCode: 500
                    };
                    Logger.log("error", JSON.stringify(errorInfo));
                    callback(true, packageId, errorInfo);
                });
            }
        }, overwrite);
    }
    // dataset not found and error occurred
    else if (!resultFromPackageExists.success && resultFromPackageExists.error.__type !== "Not Found Error")
    {
        generalDatasetUtils.deleteFolderRecursive(parentFolderPath);
        const message = "Error checking for presence of old dataset for " + requestedResourceUri + " Error reported : " + resultFromPackageExists;
        Logger.log("error", message);
        let errorInfo = {
            message: message,
            statusCode: 500
        };
        Logger.log("error", JSON.stringify(errorInfo));
        callback(true, folder, errorInfo);
    }
    else
    {
        const message = "Unable to parse response from CKAN repository.";
        let errorInfo = {
            message: message,
            statusCode: 401
        };
        Logger.log("error", JSON.stringify(errorInfo));
        callback(true, folder, errorInfo);
    }
};

module.exports = {
    validateChangesPermissions: validateChangesPermissions,
    checkResourceTypeAndChildren: checkResourceTypeAndChildren,
    deleteResourceInCkan: deleteResourceInCkan,
    updateOrInsertExportedAtByDendroForCkanDataset: updateOrInsertExportedAtByDendroForCkanDataset,
    createCkanFileIdBasedOnDendroFileName: createCkanFileIdBasedOnDendroFileName,
    verifyIfCkanFileWasCreatedInDendro: verifyIfCkanFileWasCreatedInDendro,
    calculateDendroDiffs: calculateDendroDiffs,
    getExportedAtByDendroForCkanDataset: getExportedAtByDendroForCkanDataset,
    createPackageID: createPackageID,
    checkIfResourceHasTheRequiredMetadataForExport: checkIfResourceHasTheRequiredMetadataForExport,
    getBothDendroDiffsAndCkanDiffs: getBothDendroDiffsAndCkanDiffs,
    calculateCkanRepositoryDiffs: calculateCkanRepositoryDiffs,
    createOrUpdateFilesInPackage: createOrUpdateFilesInPackage,
    createPackageInCkan: createPackageInCkan,
    updatePackageInCkan: updatePackageInCkan,
    purgeCkanDataset: purgeCkanDataset,
    buildPermissionsToBeCheck: buildPermissionsToBeCheck,
    checkIfFolderAndTargetRepositoryHaveRequiredMetadata: checkIfFolderAndTargetRepositoryHaveRequiredMetadata,
    buildExtrasJSONArray: buildExtrasJSONArray,
    buildPackageForCkanExport: buildPackageForCkanExport,
    exportPackageToCkan: exportPackageToCkan
};
